---
title: 'アルゴリズム講座・まとめ#2020-0x02'
date: 2020-05-26T23:00:00.000Z
author: にし厶た
categories:
  - course-2020
tags:
  - algorithm
---
競技プログラミング部の活動として2020年5月26日に行なわれたアルゴリズム勉強会の簡単なまとめです。
<!--more-->

# 先週の復習
[先週](https://www.yucpc.org/blog/2020/05/20/2020-05-20-%E9%83%A8%E9%95%B7%E3%81%AE%E7%AB%B6%E3%83%97%E3%83%AD%E8%AC%9B%E5%BA%A7-2020-0x01/)の内容の復習をしました。
<!-- TODO:先週の分のリンクの内容があってるかあ確認する -->


# 幅優先探索の続き(例題)
<!-- TODO: 特に解説らしい解説がないきがするのでなくてもいいかもしれない -->
## 迷路の最短経路(蟻本 p.37)
### 問題
>ここに問題<!-- TODO:蟻本p.37 の問題内容を引用すること -->>
>蟻本(p.37)より引用

### 解法
>```cpp
>// TODO:蟻本から写経する
>```
>蟻本(p.37)より引用


# next\_permutation
next\_permutation は c++ の algorithm ヘッダに含まれる関数です。
```cpp
int main() {
    int a[4] = {1, 2, 3, 4};
    do {
        for (int i = 0; i < 4; i++) {
            std::cout << a[i] << " \n"[i==3];
        }
    } while (next_permutaion(a, a+4));
    return 0;
}
```
上のように書くことで、1, 2, 3, 4 を並び変えて作ることができるパターンを全て列挙することができます。


# 枝がり
枝がりは木構造等の探索において、木の特徴を利用して無駄な探索を省く方法です。
例えば二分探索木を用いてある値を探索するとき、二分探索木の左の子は現在の値より必ず小さいという特徴から、探す値が現在の値よりも大きいのであれば左の子を探索する必要はなくなります。
実際に二分探索は枝がりを行っているということができます。


# スタック領域とヒープ領域
プログラムにおいて変数の確保等に用いられるメモリ上の領域は大きくわけて2つあります。
1つめはスタック領域で、もう1つはヒープ領域です。

スタック領域はプログラムの開始時に用意され、実行時に拡張されずまたサイズに制限があります。
再帰関数や関数内のローカル変数はスタック領域に確保されるため、再帰の回数や関数内の配列のサイズには制限がかかります。

ヒープ領域はプログラムの実行中に必要に応じて確保されるため、スタック領域に比べて上限が大きくなります。
グローバル変数や動的に確保した変数はヒープ領域上に確保されるため、大きい配列を用いる場合はグローバル変数として確保することでスタックオーバーフロー(スタック領域の上限を越えてしまう現象)を防ぐことができます。
また、通常のソフトウェエア開発ではグローバル変数は保守性の関係であまり用いるべきではありません。


# 貪欲法
貪欲法は最適(最小や最大)な値を探す方法のなかで最も単純な方法です。
貪欲法による例を2つ示します。

## 例題 (硬貨の問題)
<!-- TODO:これ蟻本の問題なら引用にかえる -->
### 問題
1円、5円、10円、50円、100円、500円の硬貨があるとしたとき、A円になるような支払い方で必要な硬貨の枚数が最も少くなる組み合わせを探せ。

### 解法
大きな額の硬貨から順に枚数を決めることで最適な枚数が求まります。

## 例題 (区間スケジューリング)
<!-- TODO:これ蟻本の問題なら引用にかえる -->
### 問題
N 個の仕事があり、各仕事 i の開始時間と終了時間はそれぞれ s_i, t_i とします。
このとき選んだ仕事の区間が重複しないような選び方のうち、選んだ仕事の個数が最大となるような選び方を求めろ。

### 解法
終了時間が短い順に仕事を選ぶ(ことのき区間が重複していれば選ばない)ことで最適となる。
正当性は帰納法と背理法によって証明することができるそうです。


# mod について
## フェルマーの小定理
素数 p, に対して任意の p 以外の a に対して
a^p = a  mod p <=> a^{p-1} = 1  mod p
が成立する。

## 逆元
mod p の世界の上での乗法に関する逆元はユークリッドの互除法を拡張して適用することで求めることができる。

フェルマーの小定理から p が素数ならば a^{p-2} が a の乗法に関する逆元となるため、繰り返し2乗法によっても逆元を得ることができます。
以下に繰り返し2乗法によるソースコードの例を示します。
ここで p は変数 mod としています。
```cpp
long long mod = 1e9 + 7;

// a^b
long long mppow(long long a, long long b) {
    if (b == 0) return 1;
    long long ret = mppow(a, b/2);
    ret *= ret;
    ret %= mod;
    if (b&1) red *= a;
    return ret % mod;
}
```
この mppow を用いて mppow(a, mod - 2) を計算することで a の逆元を計算できます。


# 連立方程式の期待値
## ランダムウォーク
### 問題
<!-- TODO:これ蟻本の問題なら引用にかえる -->
N × M のマス目で、 i, j のマスからは4方に等確率で移動するとする。
ここでいくつかのマスには石があり移動できないとする。
この前提のもとで 0, 0のマスから N-1, M-1のマスへ移動にかかる時間の期待値を求めろ。

### 解法
i, j のマスを開始点としたときにゴールまでかかる時間の期待値を E(i, j) とすることで、E(i, j) を変数とする連立方程式を立てることができます。
その連立方程式の解を計算することで、各 i, j に対して E(i, j) を求めることができ、E(0, 0) がスタートからゴールへの移動にかかる時間の期待値となります。


## 参考
<!-- TODO:参考文献があれば追加する -->
- 秋葉拓哉，岩田陽一，北川宜稔，“プログラミングコンテストチャレンジブック 第2版”，マイナビ出版，(2012)．

